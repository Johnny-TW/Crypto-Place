name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: "18"
  PNPM_VERSION: "9"
  REGISTRY: docker.io

permissions:
  contents: read
  packages: write
  security-events: write

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      frontend-cache-key: ${{ steps.cache-keys.outputs.frontend }}
      backend-cache-key: ${{ steps.cache-keys.outputs.backend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Generate cache keys
        id: cache-keys
        run: |
          echo "frontend=$(echo ${{ hashFiles('frontend/pnpm-lock.yaml', 'frontend/package.json') }})" >> $GITHUB_OUTPUT
          echo "backend=$(echo ${{ hashFiles('backend/pnpm-lock.yaml', 'backend/package.json') }})" >> $GITHUB_OUTPUT

      - name: Cache frontend dependencies
        uses: actions/cache@v4.2.0
        with:
          path: frontend/node_modules
          key: frontend-deps-${{ steps.cache-keys.outputs.frontend }}
          restore-keys: frontend-deps-

      - name: Cache backend dependencies
        uses: actions/cache@v4.2.0
        with:
          path: backend/node_modules
          key: backend-deps-${{ steps.cache-keys.outputs.backend }}
          restore-keys: backend-deps-

      - name: Install frontend dependencies
        run: |
          cd frontend
          pnpm install --frozen-lockfile

      - name: Install backend dependencies
        run: |
          cd backend
          pnpm install --frozen-lockfile

  test:
    runs-on: ubuntu-latest
    needs: setup
    strategy:
      matrix:
        service: [frontend, backend]
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore dependencies cache
        uses: actions/cache@v4.2.0
        with:
          path: ${{ matrix.service }}/node_modules
          key: ${{ format('{0}-deps-{1}', matrix.service, matrix.service == 'frontend' && needs.setup.outputs.frontend-cache-key || needs.setup.outputs.backend-cache-key) }}
          restore-keys: ${{ matrix.service }}-deps-

      - name: Run linting
        run: |
          cd ${{ matrix.service }}
          pnpm run lint

      - name: Run type checking
        run: |
          cd ${{ matrix.service }}
          pnpm run type-check

      - name: Run unit tests
        run: |
          cd ${{ matrix.service }}
          if [ "${{ matrix.service }}" = "frontend" ]; then
            pnpm run test -- --coverage --run
          else
            pnpm run test:ci
          fi

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./${{ matrix.service }}/coverage/lcov.info
          flags: ${{ matrix.service }}

      - name: Run E2E tests (frontend only)
        if: matrix.service == 'frontend' && false # æš«æ™‚åœç”¨ç›´åˆ° E2E æ¸¬è©¦é…ç½®å®Œæˆ
        run: |
          cd ${{ matrix.service }}
          pnpm run test:e2e

  # å®‰å…¨å¯©è¨ˆ (èˆ‡æ¸¬è©¦ä¸¦è¡Œ)
  security:
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore frontend dependencies
        uses: actions/cache@v4.2.0
        with:
          path: frontend/node_modules
          key: frontend-deps-${{ needs.setup.outputs.frontend-cache-key }}

      - name: Restore backend dependencies
        uses: actions/cache@v4.2.0
        with:
          path: backend/node_modules
          key: backend-deps-${{ needs.setup.outputs.backend-cache-key }}

      - name: Run dependency audit
        run: |
          echo "ðŸ” Running frontend dependency audit..."
          cd frontend
          pnpm audit --audit-level high || echo "âš ï¸ Frontend has security vulnerabilities but continuing..."
          echo "ðŸ” Running backend dependency audit..."
          cd ../backend
          pnpm audit --audit-level high || echo "âš ï¸ Backend has security vulnerabilities but continuing..."
          echo "âœ… Security audit completed (informational only)"

      - name: Run CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  build:
    runs-on: ubuntu-latest
    needs: [setup, test, security]
    strategy:
      matrix:
        service: [frontend, backend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v3
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore dependencies cache
        uses: actions/cache@v4.2.0
        with:
          path: ${{ matrix.service }}/node_modules
          key: ${{ format('{0}-deps-{1}', matrix.service, matrix.service == 'frontend' && needs.setup.outputs.frontend-cache-key || needs.setup.outputs.backend-cache-key) }}

      - name: Build application
        run: |
          cd ${{ matrix.service }}
          pnpm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-build
          path: |
            ${{ matrix.service == 'frontend' && 'frontend/build' || 'backend/dist' }}
          retention-days: 1

  docker-build:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    strategy:
      matrix:
        service: [frontend, backend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.service }}-build
          path: ${{ matrix.service == 'frontend' && 'frontend/build' || 'backend/dist' }}

      - name: Check Docker secrets
        id: docker-secrets
        run: |
          if [ -n "${{ secrets.DOCKER_USERNAME }}" ] && [ -n "${{ secrets.DOCKER_TOKEN }}" ]; then
            echo "available=true" >> $GITHUB_OUTPUT
          else
            echo "available=false" >> $GITHUB_OUTPUT
          fi

      - name: Login to Docker Hub
        if: steps.docker-secrets.outputs.available == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }} # ä½¿ç”¨ Token è€Œéžå¯†ç¢¼

      - name: Extract metadata
        if: steps.docker-secrets.outputs.available == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: johnny23511/crypto-place-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        if: steps.docker-secrets.outputs.available == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/${{ matrix.service == 'frontend' && 'Dockerfile.prod' || 'Dockerfile' }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ${{ matrix.service == 'frontend' && format('VITE_API_BASE_URL={0}', vars.VITE_API_BASE_URL || 'http://localhost:5001') || '' }}

      - name: Run security scan on image
        if: steps.docker-secrets.outputs.available == 'true'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: johnny23511/crypto-place-${{ matrix.service }}:latest
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results
        if: steps.docker-secrets.outputs.available == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-results.sarif"

  # ==================== AWS EC2 éƒ¨ç½² ====================
  deploy-aws-ec2:
    runs-on: ubuntu-latest
    needs: docker-build
    if: github.ref == 'refs/heads/main' && vars.DEPLOY_TARGET == 'aws-ec2'
    environment:
      name: production
      url: ${{ vars.FRONTEND_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_EC2_SSH_KEY }}" > ~/.ssh/ec2-key.pem
          chmod 600 ~/.ssh/ec2-key.pem
          ssh-keyscan -H ${{ secrets.AWS_EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to AWS EC2
        env:
          EC2_HOST: ${{ secrets.AWS_EC2_HOST }}
          EC2_USER: ${{ secrets.AWS_EC2_USER }}
          EC2_PATH: ${{ secrets.AWS_EC2_PATH }}
        run: |
          echo "ðŸš€ é–‹å§‹éƒ¨ç½²åˆ° AWS EC2..."

          ssh -i ~/.ssh/ec2-key.pem $EC2_USER@$EC2_HOST << 'EOF'
            set -e

            echo "ðŸ“‚ é€²å…¥å°ˆæ¡ˆç›®éŒ„..."
            cd ${{ secrets.AWS_EC2_PATH }}

            echo "ðŸ“¦ æ‹‰å–æœ€æ–°ä»£ç¢¼..."
            git fetch origin
            git reset --hard origin/main
            git pull origin main

            echo "ðŸ”§ è¨­å®šåŸ·è¡Œæ¬Šé™..."
            chmod +x scripts/*.sh

            echo "ðŸš€ åŸ·è¡Œéƒ¨ç½²..."
            ./scripts/deploy.sh production

            echo "âœ… éƒ¨ç½²å®Œæˆ!"
          EOF

          echo "âœ… AWS EC2 éƒ¨ç½²æˆåŠŸ!"

      - name: Verify deployment
        run: |
          echo "ðŸ” é©—è­‰éƒ¨ç½²..."
          sleep 15

          # æ¸¬è©¦ Frontend
          if curl -f -s -o /dev/null --max-time 10 "http://${{ secrets.AWS_EC2_HOST }}:3001"; then
            echo "âœ… Frontend é‹è¡Œæ­£å¸¸"
          else
            echo "âš ï¸ Frontend ç„¡æ³•è¨ªå•"
          fi

          # æ¸¬è©¦ Backend
          if curl -f -s --max-time 10 "http://${{ secrets.AWS_EC2_HOST }}:5001/api/health"; then
            echo "âœ… Backend API é‹è¡Œæ­£å¸¸"
          else
            echo "âš ï¸ Backend API ç„¡æ³•è¨ªå•"
          fi

  # ==================== AWS ECS éƒ¨ç½² ====================
  deploy-aws-ecs:
    runs-on: ubuntu-latest
    needs: docker-build
    if: github.ref == 'refs/heads/main' && vars.DEPLOY_TARGET == 'aws-ecs'
    environment:
      name: production
      url: ${{ vars.FRONTEND_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Frontend to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: crypto-place-frontend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ðŸ—ï¸ å»ºç½® Frontend æ˜ åƒ..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -f frontend/Dockerfile.prod frontend/
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "ðŸ“¤ æŽ¨é€åˆ° ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "âœ… Frontend æ˜ åƒå·²æŽ¨é€"

      - name: Build and push Backend to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: crypto-place-backend
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "ðŸ—ï¸ å»ºç½® Backend æ˜ åƒ..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG backend/
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "ðŸ“¤ æŽ¨é€åˆ° ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "âœ… Backend æ˜ åƒå·²æŽ¨é€"

      - name: Update ECS Frontend Service
        run: |
          echo "ðŸ”„ æ›´æ–° ECS Frontend æœå‹™..."
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE_FRONTEND }} \
            --force-new-deployment \
            --region ${{ secrets.AWS_REGION }}

      - name: Update ECS Backend Service
        run: |
          echo "ðŸ”„ æ›´æ–° ECS Backend æœå‹™..."
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE_BACKEND }} \
            --force-new-deployment \
            --region ${{ secrets.AWS_REGION }}

      - name: Wait for deployment
        run: |
          echo "â³ ç­‰å¾…éƒ¨ç½²å®Œæˆ..."
          aws ecs wait services-stable \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --services ${{ secrets.ECS_SERVICE_FRONTEND }} ${{ secrets.ECS_SERVICE_BACKEND }} \
            --region ${{ secrets.AWS_REGION }}

          echo "âœ… ECS éƒ¨ç½²å®Œæˆ!"

  # ==================== æœ¬åœ°æ¸¬è©¦éƒ¨ç½² (ä¿ç•™åŽŸæœ‰é‚è¼¯) ====================
  deploy:
    runs-on: ubuntu-latest
    needs: docker-build
    if: github.ref == 'refs/heads/main' && (vars.DEPLOY_TARGET == '' || vars.DEPLOY_TARGET == 'local')
    environment:
      name: production
      url: ${{ vars.FRONTEND_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create production environment file
        run: |
          echo "ðŸ“ å‰µå»ºç”Ÿç”¢ç’°å¢ƒè¨­å®šæª”..."
          cat > .env.prd << EOF
          NODE_ENV=production
          POSTGRES_DB=crypto_place_prd
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || 'temp_password' }}
          POSTGRES_PORT=5432
          FRONTEND_PORT=3001
          BACKEND_PORT=5001
          VITE_API_BASE_URL=http://backend:5001
          VITE_API_HOST=/api
          VITE_COINGECKO_API_KEY=${{ secrets.COINGECKO_API_KEY || 'CG-nrJXAB28gG2xbfsdLieGcxWB' }}
          EOF
          echo "âœ… ç’°å¢ƒæª”æ¡ˆå·²å»ºç«‹"

      - name: Deploy to production (Local Test)
        run: |
          echo "ðŸš€ Deploying to production..."

          # æ–¹æ¡ˆ 1: æœ¬åœ° Docker Compose éƒ¨ç½² (é©åˆæ¸¬è©¦)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "ðŸ“¦ æº–å‚™ Docker Compose éƒ¨ç½²..."
            chmod +x ./scripts/deploy.sh

            # åœ¨ CI/CD ç’°å¢ƒä¸­ï¼Œæˆ‘å€‘åªèƒ½æ¨¡æ“¬éƒ¨ç½²æµç¨‹
            echo "ðŸ”¨ å»ºç½® Docker æ˜ åƒæª”..."
            docker compose -f docker-compose.prod.yml build

            echo "ðŸ§ª æ¸¬è©¦æœå‹™å•Ÿå‹•..."
            docker compose -f docker-compose.prod.yml up -d
            sleep 10

            echo "ðŸ” æª¢æŸ¥æœå‹™ç‹€æ…‹..."
            docker compose -f docker-compose.prod.yml ps

            echo "ðŸ›‘ åœæ­¢æ¸¬è©¦æœå‹™..."
            docker compose -f docker-compose.prod.yml down

            echo "âœ… éƒ¨ç½²é©—è­‰å®Œæˆï¼"
            echo "ðŸ“‹ å¯¦éš›éƒ¨ç½²æ­¥é©Ÿï¼š"
            echo "   1. åœ¨ç›®æ¨™æœå‹™å™¨åŸ·è¡Œ: git pull origin main"
            echo "   2. åœ¨ç›®æ¨™æœå‹™å™¨åŸ·è¡Œ: ./scripts/deploy.sh production"
          fi

      - name: Run health checks
        if: ${{ vars.FRONTEND_URL && vars.BACKEND_URL }}
        run: |
          echo "ðŸ” Running health checks..."
          chmod +x ./scripts/health-check.sh
          ./scripts/health-check.sh ${{ vars.FRONTEND_URL }} ${{ vars.BACKEND_URL }}
          echo "âœ… Health checks passed!"

      - name: Notify deployment status
        if: always() && env.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            ðŸš€ Deployment ${{ job.status }} for commit ${{ github.sha }}
            ðŸ“ Repository: ${{ github.repository }}
            ðŸŒ¿ Branch: ${{ github.ref_name }}

            âœ… CI/CD Pipeline completed successfully!
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
